<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xdk-nj.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MySQL高级">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL高级">
<meta property="og:url" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="打醒月亮">
<meta property="og:description" content="MySQL高级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/42.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/41.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/40.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/43.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/44.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/45.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/46.bmp">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/46.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/47.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/48.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/49.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/50.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/51.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/52.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/53.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/54.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/55.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/56.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/57.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/59.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/60.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/61.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/62.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/63.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/64.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/65.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/66.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/67.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/68.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/69.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/70.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/71.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/72.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/74.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/75.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/81.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/82.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/76.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/77.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/78.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/79.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/80.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/83.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/84.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/85.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/86.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/87.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/88.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/89.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/90.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/91.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/92.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/93.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/94.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/95.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/96.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/97.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/98.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/99.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/100.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/108.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/109.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/110.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/111.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/112.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/113.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/114.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/115.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc1.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc2.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc3.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc4.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/116.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/117.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/99.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/101.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/102.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/98.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/103.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/104.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/105.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/106.png">
<meta property="og:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/107.png">
<meta property="article:published_time" content="2021-01-25T00:16:04.000Z">
<meta property="article:modified_time" content="2021-01-25T03:57:20.096Z">
<meta property="article:author" content="xudukang">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/42.png">

<link rel="canonical" href="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL高级 | 打醒月亮</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="打醒月亮" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">打醒月亮</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xdk-nj.github.io/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xudukang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打醒月亮">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL高级
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-25 08:16:04 / 修改时间：11:57:20" itemprop="dateCreated datePublished" datetime="2021-01-25T08:16:04+08:00">2021-01-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h2 id="第一章-MySQL架构介绍"><a href="#第一章-MySQL架构介绍" class="headerlink" title="第一章 MySQL架构介绍"></a>第一章 MySQL架构介绍</h2><h3 id="MySQL中的一些文件"><a href="#MySQL中的一些文件" class="headerlink" title="MySQL中的一些文件"></a>MySQL中的一些文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置文件 Windows my.ini   Linux  my.cnf        </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 数据文件 </span><br><span class="line">MyIsam</span><br><span class="line">	frm文件(framework)  存放表结构</span><br><span class="line">	myd文件(data)   存放表数据</span><br><span class="line">	myi文件(index)  存放表索引</span><br><span class="line">Innodb</span><br><span class="line">	frm文件  存放表结构</span><br><span class="line">	ibdata1  所有表的数据都存在<span class="operator">/</span>usr<span class="operator">/</span>share<span class="operator">/</span>MySQL<span class="operator">/</span>ibdata1, 而frm文件存放在库同名的包下</span><br><span class="line">也可以单独存放，如下图所示：</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/42.png" alt="42"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 日志文件</span><br><span class="line"><span class="operator">-</span> 重做日志（redo log）</span><br><span class="line"><span class="operator">-</span> 回滚日志（undo log）</span><br><span class="line"><span class="operator">-</span> 二进制日志（binlog）</span><br><span class="line"><span class="operator">-</span> 错误日志（errorlog）</span><br><span class="line"><span class="operator">-</span> 慢查询日志（slow query log）</span><br><span class="line"><span class="operator">-</span> 一般查询日志（general query log）</span><br><span class="line"><span class="operator">-</span> 中继日志（relay log）</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重做日志（redo log）</span></span><br><span class="line"><span class="comment">--作用：</span></span><br><span class="line">确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启MySQL服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</span><br><span class="line"></span><br><span class="line"><span class="comment">--内容：</span></span><br><span class="line">物理格式的日志，记录物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</span><br><span class="line"></span><br><span class="line"><span class="comment">--什么时候产生：</span></span><br><span class="line">事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</span><br><span class="line"></span><br><span class="line"><span class="comment">--什么时候释放：</span></span><br><span class="line">当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用。</span><br><span class="line"></span><br><span class="line"><span class="comment">--很重要一点，redo log是什么时候写盘的？</span></span><br><span class="line">前面说了是在事物开始之后逐步写盘的。之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为<span class="number">8</span>M,Innodb存储引擎先将重做日志写入innodb_log_buffer中。</span><br><span class="line"></span><br><span class="line"><span class="comment">--然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘</span></span><br><span class="line">Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</span><br><span class="line">每个事务提交时会将重做日志刷新到重做日志文件。</span><br><span class="line">当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件</span><br><span class="line"></span><br><span class="line">由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。</span><br><span class="line">因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</span><br><span class="line">即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。</span><br><span class="line">这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（<span class="keyword">commit</span>）的时间也是很短暂的。</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚日志（undo log）</span></span><br><span class="line"><span class="comment">--作用：</span></span><br><span class="line">保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</span><br><span class="line"></span><br><span class="line"><span class="comment">--内容：</span></span><br><span class="line">逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</span><br><span class="line"></span><br><span class="line"><span class="comment">--什么时候产生：</span></span><br><span class="line">事务开始之前，将当前的版本生成 undo log，undo 也会产生 redo 来保证undo log的可靠性</span><br><span class="line"></span><br><span class="line"><span class="comment">--什么时候释放：</span></span><br><span class="line">当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</span><br><span class="line"></span><br><span class="line"><span class="comment">--对应的物理文件：</span></span><br><span class="line">MySQL5<span class="number">.6</span>之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</span><br><span class="line"></span><br><span class="line">MySQL5<span class="number">.6</span>之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数</span><br><span class="line"></span><br><span class="line">如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</span><br><span class="line"></span><br><span class="line"><span class="comment">--其他：</span></span><br><span class="line">undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redo log的产生。</span><br><span class="line"></span><br><span class="line">默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</span><br><span class="line"></span><br><span class="line">因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被撑大的共享表空间是不会也不能自动收缩的。</span><br><span class="line"></span><br><span class="line">因此，MySQL5<span class="number">.7</span>之后的独立undo 表空间的配置就显得很有必要了。</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 二进制日志（binlog）：</span></span><br><span class="line"><span class="comment">--作用：</span></span><br><span class="line">用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</span><br><span class="line">用于数据库的基于时间点的还原。</span><br><span class="line"></span><br><span class="line"><span class="comment">--内容：</span></span><br><span class="line">逻辑格式的日志，可以简单认为就是执行过的事务中的<span class="keyword">sql</span>语句。</span><br><span class="line"></span><br><span class="line">但又不完全是<span class="keyword">sql</span>语句这么简单，而是包括了执行的<span class="keyword">sql</span>语句（增删改）反向的信息，也就意味着<span class="keyword">delete</span>对应着<span class="keyword">delete</span>本身和其反向的<span class="keyword">insert</span>；<span class="keyword">update</span>对应着<span class="keyword">update</span>执行前后的版本的信息；<span class="keyword">insert</span>对应着<span class="keyword">delete</span>和<span class="keyword">insert</span>本身的信息。</span><br><span class="line"></span><br><span class="line">在使用MySQLbinlog解析binlog之后一些都会真相大白。</span><br><span class="line"></span><br><span class="line">因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</span><br><span class="line"></span><br><span class="line"><span class="comment">--什么时候产生：</span></span><br><span class="line">事务提交的时候，一次性将事务中的<span class="keyword">sql</span>语句（一个事物可能对应多个<span class="keyword">sql</span>语句）按照一定的格式记录到binlog中。</span><br><span class="line"></span><br><span class="line">这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</span><br><span class="line"></span><br><span class="line">因此对于事务的提交，即便是较大的事务，提交（<span class="keyword">commit</span>）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</span><br><span class="line"></span><br><span class="line">这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</span><br><span class="line"></span><br><span class="line"><span class="comment">--什么时候释放：</span></span><br><span class="line"></span><br><span class="line">binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</span><br><span class="line"></span><br><span class="line"><span class="comment">--对应的物理文件：</span></span><br><span class="line">配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</span><br><span class="line"></span><br><span class="line">对于每个binlog日志文件，通过一个统一的index文件来组织。</span><br><span class="line"></span><br><span class="line"><span class="comment">--其他：</span></span><br><span class="line">二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</span><br><span class="line"></span><br><span class="line">作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</span><br><span class="line"></span><br><span class="line">内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是<span class="keyword">sql</span>语句</span><br><span class="line"></span><br><span class="line">另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</span><br><span class="line"></span><br><span class="line">恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</span><br><span class="line"></span><br><span class="line">关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 四、错误日志</span></span><br><span class="line">错误日志记录着MySQLd启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 五、普通查询日志 general query log </span></span><br><span class="line">记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来 ，记录的格式为 &#123;Time ，Id ，Command，Argument &#125;。也正因为MySQL服务器需要不断地记录日志，开启General log会产生不小的系统开销。 因此，MySQL默认是把General log关闭的。</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 六、慢查询日志 </span></span><br><span class="line">慢日志记录执行时间过长和没有使用索引的查询语句，报错<span class="keyword">select</span>、<span class="keyword">update</span>、<span class="keyword">delete</span>以及<span class="keyword">insert</span>语句，慢日志只会记录执行成功的语句。</span><br><span class="line"><span class="number">1.</span> 查看慢查询时间： </span><br><span class="line">　　<span class="keyword">show</span> variables <span class="keyword">like</span> &quot;long_query_time&quot;; 默认<span class="number">10</span>s</span><br><span class="line"><span class="number">2.</span> 查看慢查询配置情况： </span><br><span class="line">　　<span class="keyword">show</span> status <span class="keyword">like</span> &quot;%slow_queries%&quot;;</span><br><span class="line"><span class="number">3.</span> 查看慢查询日志路径： </span><br><span class="line">　　<span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%slow%&quot;;</span><br><span class="line"><span class="number">4.</span> 开启慢日志</span><br><span class="line">	<span class="keyword">set</span> <span class="keyword">global</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">5.</span> 查看已经开启：</span><br><span class="line">	<span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%slow_query_log%&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="MySQL逻辑架构介绍"><a href="#MySQL逻辑架构介绍" class="headerlink" title="MySQL逻辑架构介绍"></a>MySQL逻辑架构介绍</h3><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/41.png" alt="41"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>连接层</span><br><span class="line">最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端<span class="operator">/</span>服务端工具实现的类似于tcp<span class="operator">/</span>ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>服务层</span><br><span class="line"><span class="number">2.1</span>  Management Serveices <span class="operator">&amp;</span> Utilities： 系统管理和控制工具  </span><br><span class="line"><span class="number">2.2</span>  <span class="keyword">SQL</span> Interface: <span class="keyword">SQL</span>接口</span><br><span class="line">     接受用户的<span class="keyword">SQL</span>命令，并且返回用户需要查询的结果。比如<span class="keyword">select</span> <span class="keyword">from</span>就是调用<span class="keyword">SQL</span> Interface</span><br><span class="line"><span class="number">2.3</span> Parser: 解析器</span><br><span class="line">    <span class="keyword">SQL</span>命令传递到解析器的时候会被解析器验证和解析。 </span><br><span class="line"><span class="number">2.4</span> Optimizer: 查询优化器。</span><br><span class="line">    <span class="keyword">SQL</span>语句在查询之前会使用查询优化器对查询进行优化。 </span><br><span class="line">    用一个例子就可以理解： <span class="keyword">select</span> uid,name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  gender<span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    优化器来决定先投影还是先过滤。</span><br><span class="line"><span class="number">2.5</span> Cache和Buffer： 查询缓存。</span><br><span class="line">    如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</span><br><span class="line">    这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</span><br><span class="line">    缓存是负责读，缓冲负责写。</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>引擎层</span><br><span class="line">存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span>存储层</span><br><span class="line">数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</span><br></pre></td></tr></table></figure>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/40.png" alt="40"></p>
<h2 id="第二章-索引优化分析"><a href="#第二章-索引优化分析" class="headerlink" title="第二章  索引优化分析"></a>第二章  索引优化分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">性能下降的原因</span><br><span class="line">- 查询数据过多</span><br><span class="line">- 关联了太多的表，太多join </span><br><span class="line">- 没有利用到索引</span><br><span class="line">- 服务器调优及各个参数设置（缓冲、线程数等）(DBA的工作)</span><br></pre></td></tr></table></figure>
<h3 id="常见的Join查询"><a href="#常见的Join查询" class="headerlink" title="常见的Join查询"></a>常见的Join查询</h3><h4 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h4><ul>
<li><p>手写</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/43.png" alt="43"></p>
</li>
<li><p>机读</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/44.png" alt="44"></p>
</li>
<li><p>总结</p>
</li>
</ul>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/45.png" alt="45"></p>
<h4 id="JOIN图"><a href="#JOIN图" class="headerlink" title="JOIN图"></a>JOIN图</h4><p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/46.bmp" alt="46"></p>
<h4 id="7种JOIN"><a href="#7种JOIN" class="headerlink" title="7种JOIN"></a>7种JOIN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> A、B两表共有</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_emp a <span class="keyword">inner</span> <span class="keyword">join</span> t_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span> A、B两表共有<span class="operator">+</span>A的独有</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_emp a <span class="keyword">left</span> <span class="keyword">join</span> t_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span> A、B两表共有<span class="operator">+</span>B的独有</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_emp a <span class="keyword">right</span> <span class="keyword">join</span> t_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span> A的独有 </span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_emp a <span class="keyword">left</span> <span class="keyword">join</span> t_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="keyword">null</span>; </span><br><span class="line"> </span><br><span class="line"><span class="number">5</span> B的独有</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_emp a <span class="keyword">right</span> <span class="keyword">join</span> t_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">where</span> a.deptId <span class="keyword">is</span> <span class="keyword">null</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="number">6</span> AB全有</span><br><span class="line">MySQL不支持<span class="keyword">FULL</span> <span class="keyword">JOIN</span>, <span class="keyword">left</span> <span class="keyword">join</span> <span class="operator">+</span> <span class="keyword">union</span>(可去除重复数据)<span class="operator">+</span> <span class="keyword">right</span> <span class="keyword">join</span>代替</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept B <span class="keyword">ON</span> A.deptId <span class="operator">=</span> B.id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t_dept B <span class="keyword">ON</span> A.deptId <span class="operator">=</span> B.id</span><br><span class="line"> </span><br><span class="line"><span class="number">7</span> A的独有<span class="operator">+</span>B的独有</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_dept B <span class="keyword">ON</span> A.deptId <span class="operator">=</span> B.id <span class="keyword">WHERE</span> B.`id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t_dept B <span class="keyword">ON</span> A.deptId <span class="operator">=</span> B.id <span class="keyword">WHERE</span> A.`deptId` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">索引（Index）是帮助MySQL高效获取数据的数据结构。</span><br><span class="line"></span><br><span class="line">优势： </span><br><span class="line">- 提高数据检索的效率，降低数据库的IO成本</span><br><span class="line">- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</span><br><span class="line"></span><br><span class="line">劣势：</span><br><span class="line">- 实索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也要占用空间</span><br><span class="line">- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。</span><br><span class="line">  因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带   来的键值变化后的索引信息</span><br><span class="line">- 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就要花时间建立优秀的索引，或优化查询语句</span><br><span class="line"></span><br><span class="line">MySQL索引分类</span><br><span class="line">- 主键索引   </span><br><span class="line">- 单值索引  </span><br><span class="line">- 唯一索引 </span><br><span class="line">- 复合索引</span><br><span class="line"></span><br><span class="line">哪些情况需要创建索引</span><br><span class="line">1. 主键自动建立唯一索引</span><br><span class="line">2. 频繁作为查询条件的字段应该创建索引(where 后面的语句)</span><br><span class="line">3. 查询中与其它表关联的字段，外键关系建立索引</span><br><span class="line">4. 单键&#x2F;组合索引的选择问题(在高并发下倾向创建组合索引)</span><br><span class="line">5. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</span><br><span class="line">6. 查询中统计或者分组字段</span><br><span class="line"></span><br><span class="line">哪些情况不要创建索引</span><br><span class="line">1. 表记录太少</span><br><span class="line">2. 经常增删改的表</span><br><span class="line">3. Where条件里用不到的字段不创建索引</span><br><span class="line">4. 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的效果</span><br></pre></td></tr></table></figure>
<h3 id="性能分析Explain"><a href="#性能分析Explain" class="headerlink" title="性能分析Explain"></a>性能分析Explain</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 能干嘛</span></span><br><span class="line"><span class="number">1.</span>表的读取顺序</span><br><span class="line"><span class="number">2.</span>哪些索引可以使用</span><br><span class="line"><span class="number">3.</span>数据读取操作的操作类型</span><br><span class="line"><span class="number">4.</span>哪些索引被实际使用</span><br><span class="line"><span class="number">5.</span>表之间的引用</span><br><span class="line"><span class="number">6.</span>每张表有多少行被优化器查询</span><br></pre></td></tr></table></figure>
<h4 id="各字段的解释"><a href="#各字段的解释" class="headerlink" title="各字段的解释"></a>各字段的解释</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id : select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</span></span><br><span class="line"><span class="operator">-</span> id相同，执行顺序由上至下</span><br><span class="line"><span class="operator">-</span> id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</span><br><span class="line"><span class="operator">-</span> id相同不同，同时存在</span><br><span class="line"></span><br><span class="line">id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</span><br><span class="line">衍生表 <span class="operator">=</span> derived2 <span class="comment">--&gt; derived + 2 (2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/46.png" alt="46"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- select_type : 查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> SIMPLE </span><br><span class="line">   简单的 <span class="keyword">select</span> 查询,查询中不包含子查询或者<span class="keyword">UNION</span>             </span><br><span class="line"><span class="number">2.</span> <span class="keyword">PRIMARY</span>   </span><br><span class="line">   查询中若包含任何复杂的子部分，最外层查询则被标记为<span class="keyword">Primary</span>      </span><br><span class="line"><span class="number">3.</span> DERIVED       </span><br><span class="line">   在<span class="keyword">FROM</span>列表中包含的子查询被标记为DERIVED,  MySQL会递归执行这些子查询, 把结果放在临时表里。   </span><br><span class="line"><span class="number">4.</span> SUBQUERY  </span><br><span class="line">   在<span class="keyword">SELECT</span>或<span class="keyword">WHERE</span>列表中包含了子查询</span><br><span class="line"><span class="number">5.</span> DEPENDENT SUBQUERY  </span><br><span class="line">   在<span class="keyword">SELECT</span>或<span class="keyword">WHERE</span>列表中包含了子查询,子查询基于外层</span><br><span class="line"><span class="number">6.</span> UNCACHEABLE SUBQUREY    </span><br><span class="line">   无法被缓存的子查询</span><br><span class="line"><span class="number">7.</span> <span class="keyword">UNION</span>   </span><br><span class="line">   若第二个<span class="keyword">SELECT</span>出现在<span class="keyword">UNION</span>之后，则被标记为<span class="keyword">UNION</span>；</span><br><span class="line">   若<span class="keyword">UNION</span>包含在<span class="keyword">FROM</span>子句的子查询中,外层<span class="keyword">SELECT</span>将被标记为：DERIVED</span><br><span class="line"><span class="number">8.</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span>    </span><br><span class="line">   从<span class="keyword">UNION</span>表获取结果的<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table : 显示这一行的数据是关于哪张表的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- type : 显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是： </span></span><br><span class="line"><span class="keyword">system</span>  <span class="operator">&gt;</span>  const  <span class="operator">&gt;</span> eq_ref  <span class="operator">&gt;</span>  <span class="keyword">ref</span>  <span class="operator">&gt;</span>  fulltext  <span class="operator">&gt;</span>  ref_or_null  <span class="operator">&gt;</span>  index_merge  <span class="operator">&gt;</span>  unique_subquery  <span class="operator">&gt;</span> index_subquery  <span class="operator">&gt;</span>  <span class="keyword">range</span>  <span class="operator">&gt;</span>  index  <span class="operator">&gt;</span>  <span class="keyword">ALL</span> </span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/47.png" alt="47"></p>
<ol>
<li><p>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现</p>
</li>
<li><p>const：通过索引一次就找到了，const用于比较primary key或者unique索引。只匹配一行数据，所以快</p>
<p>如将主键置于where列表中，MySQL就能将该查询转换为一个常量<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/48.png" alt="48"></p>
</li>
<li><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/49.png" alt="49"></p>
</li>
<li><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。</p>
<p>本质上是一种索引访问，返回所有匹配某个单独值的行。</p>
</li>
<li><p>range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引。</p>
<p>一般就是在where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/50.png" alt="50"></p>
</li>
<li><p>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/51.png" alt="51"></p>
</li>
<li><p>all：Full Table Scan，将遍历全表以找到匹配的行</p>
</li>
<li><p>index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/52.png" alt="52"></p>
</li>
<li><p>ref_or_null：对于某个字段既需要关联条件，也需要null值。查询优化器会选择用ref_or_null连接查询。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/53.png" alt="53"></p>
</li>
<li><p>index_subquery：利用索引来关联子查询，不再全表扫描。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/54.png" alt="54"></p>
</li>
<li><p>unique_subquery ：该连接类型类似于index_subquery。 子查询中的唯一索引</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/55.png" alt="55"></p>
</li>
</ol>
<p>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- possible_keys：显示可能应用在这张表中的索引，一个或多个。</span></span><br><span class="line">查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- key：实际使用的索引。如果为NULL，则没有使用索引</span></span><br><span class="line">查询中若使用了覆盖索引，则该索引和查询的<span class="keyword">select</span>字段重叠</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 </span></span><br><span class="line">key_len字段能够帮你检查是否充分的利用上了索引</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/56.png" alt="56"></p>
<p> <img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/57.png" alt="57"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">char(30)   utf8 --&gt;  key_len &#x3D; 30*3 +1  表示 utf8 格式需要  *3 (跟数据类型有关)   </span><br><span class="line">允许为 NULL    +1  ，不允许 +0</span><br><span class="line">动态类型 +2  (动态类型包括 : varchar , detail text() 截取字符串)</span><br></pre></td></tr></table></figure>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/59.png" alt="59"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- rows：rows列显示MySQL认为它执行查询时必须检查的行数。（越少越好）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Extra：包含十分重要的额外信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p>Using filesort     </p>
<p>说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<br>MySQL中无法利用索引完成的排序操作称为“文件排序”</p>
</li>
<li><p>Using temporary </p>
<p>使了用临时表保存中间结果, MySQL在对查询结果排序时使用临时表。常见于排序 和分组查询。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/60.png" alt="60"></p>
<p>create index idx_deptno_ename on emp(deptno,ename)</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/61.png" alt="61"></p>
</li>
<li><p>USING index</p>
<p>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！<br>如果同时出现using where，表明索引被用来执行索引键值的查找;<br>如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p>
<p>注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>
</li>
<li><p>Using where              表明使用了where过滤</p>
</li>
<li><p>using join buffer       使用了连接缓存</p>
</li>
<li><p>impossible where     where子句的值总是false，不能用来获取任何元组</p>
</li>
<li><p>select tables optimized away    </p>
<p>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/62.png" alt="62"></p>
</li>
<li><p>distinct                        优化distinct操作</p>
</li>
</ol>
</blockquote>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 全值匹配</span><br><span class="line"><span class="number">2.</span> 左前缀法则</span><br><span class="line">	如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。 </span><br><span class="line">	<span class="keyword">and</span> 忽略左右关系。既即使没有没有按顺序由于优化器的存在，会自动优化。</span><br><span class="line">	经过试验结论 ：建立了idx_nameAge索引  id 为主键</span><br><span class="line">    <span class="number">1</span>).当使用覆盖索引的方式时，(<span class="keyword">select</span> name<span class="operator">/</span>age<span class="operator">/</span>id <span class="keyword">from</span> staffs <span class="keyword">where</span> age<span class="operator">=</span><span class="number">10</span> 后面没有其他没有索引的	        字段条件)，即使不是以 name 开头，也会使用 idx_nameAge 索引。</span><br><span class="line">    <span class="number">2</span>).除开上述条件才满足最左前缀法则。</span><br><span class="line"><span class="number">3.</span> 不在索引列上做任何操作（计算、函数、(自动<span class="keyword">or</span>手动)类型转换），会导致索引失效转向全表扫描</span><br><span class="line"><span class="number">4.</span> 存储引擎不能使用索引中范围条件右边的列</span><br><span class="line"><span class="number">5.</span> 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="number">6.</span> 使用不等于(<span class="operator">!=</span> 或者<span class="operator">&lt;&gt;</span>) 的时候无法使用索引会导致全表扫描</span><br><span class="line">	使用 <span class="operator">!=</span> 和 <span class="operator">&lt;&gt;</span> 的字段索引失效 (<span class="operator">!=</span> 针对数值类型。 <span class="operator">&lt;&gt;</span> 针对字符类型)</span><br><span class="line">	<span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">10</span> <span class="keyword">and</span> name<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>, 这种情况下MySQL自动优化，将 name<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> 放在 age<span class="operator">=</span><span class="number">10</span> 之前，</span><br><span class="line">	name 依然能使用索引，只是 age 的索引失效。</span><br><span class="line"><span class="number">7.</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 和 <span class="keyword">is</span> <span class="keyword">null</span>是可以使用索引的</span><br><span class="line"><span class="number">8.</span> <span class="keyword">like</span>以通配符开头(<span class="string">&#x27;%abc...&#x27;</span>) 索引失效</span><br><span class="line">	解决<span class="keyword">like</span> <span class="string">&#x27;%字符串%&#x27;</span> 时索引不被使用 <span class="comment">--&gt; 利用覆盖索引</span></span><br><span class="line"><span class="number">9.</span> 字符串不加单引号索引失效</span><br><span class="line"><span class="number">10.</span> 用<span class="keyword">or</span>连接时会索引失效</span><br></pre></td></tr></table></figure>
<p>案例7： is not null 和 is null是可以使用索引的,见下图</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/63.png" alt="63"></p>
<p>案例8：<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/64.png" alt="64"></p>
<p>案例10：用or连接时会索引失效<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/65.png" alt="65"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 练习</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test03(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary</span> <span class="keyword">key</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line"> c1 <span class="type">char</span>(<span class="number">10</span>), c2 <span class="type">char</span>(<span class="number">10</span>),c3 <span class="type">char</span>(<span class="number">10</span>),c4 <span class="type">char</span>(<span class="number">10</span>),c5 <span class="type">char</span>(<span class="number">10</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test03(c1,c2,c3,c4,c5) <span class="keyword">values</span>(<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;a2&#x27;</span>,<span class="string">&#x27;a3&#x27;</span>,<span class="string">&#x27;a4&#x27;</span>,<span class="string">&#x27;a5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test03(c1,c2,c3,c4,c5) <span class="keyword">values</span>(<span class="string">&#x27;b1&#x27;</span>,<span class="string">&#x27;b2&#x27;</span>,<span class="string">&#x27;b3&#x27;</span>,<span class="string">&#x27;b4&#x27;</span>,<span class="string">&#x27;b5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test03(c1,c2,c3,c4,c5) <span class="keyword">values</span>(<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c4&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test03(c1,c2,c3,c4,c5) <span class="keyword">values</span>(<span class="string">&#x27;d1&#x27;</span>,<span class="string">&#x27;d2&#x27;</span>,<span class="string">&#x27;d3&#x27;</span>,<span class="string">&#x27;d4&#x27;</span>,<span class="string">&#x27;d5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test03(c1,c2,c3,c4,c5) <span class="keyword">values</span>(<span class="string">&#x27;e1&#x27;</span>,<span class="string">&#x27;e2&#x27;</span>,<span class="string">&#x27;e3&#x27;</span>,<span class="string">&#x27;e4&#x27;</span>,<span class="string">&#x27;e5&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> index idx_test03_c1234 <span class="keyword">on</span> test03(c1,c2,c3,c4);</span><br><span class="line">问题：我们创建了复合索引idx_test03_c1234 ,根据以下<span class="keyword">SQL</span>分析下索引使用情况？</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c2<span class="operator">=</span><span class="string">&#x27;a2&#x27;</span> <span class="keyword">and</span> c4<span class="operator">=</span><span class="string">&#x27;a4&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c3;   </span><br><span class="line">   c1 c2 用到  c3也用到了, 但用在了排序</span><br><span class="line">   </span><br><span class="line">(<span class="number">2</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c2<span class="operator">=</span><span class="string">&#x27;a2&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c3; 同上</span><br><span class="line"> </span><br><span class="line">(<span class="number">3</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c2<span class="operator">=</span><span class="string">&#x27;a2&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c4;   <span class="keyword">using</span> filesort;</span><br><span class="line"> </span><br><span class="line">(<span class="number">4</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c5<span class="operator">=</span><span class="string">&#x27;a5&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c2,c3;   </span><br><span class="line">   只用c1一个字段索引,但是c2、c3用于排序,无filesort</span><br><span class="line">   </span><br><span class="line">(<span class="number">5</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c5<span class="operator">=</span><span class="string">&#x27;a5&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c3,c2;  </span><br><span class="line">   出现了filesort，我们建的索引是<span class="number">1234</span>，它没有按照顺序来, <span class="number">3</span> <span class="number">2</span> 颠倒了</span><br><span class="line">   </span><br><span class="line">(<span class="number">6</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c2<span class="operator">=</span><span class="string">&#x27;a2&#x27;</span> <span class="keyword">and</span> c5<span class="operator">=</span><span class="string">&#x27;a5&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c2,c3;  </span><br><span class="line">   用c1、c2两个字段索引，但是c2、c3用于排序,无filesort</span><br><span class="line">   </span><br><span class="line">(<span class="number">7</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c2<span class="operator">=</span><span class="string">&#x27;a2&#x27;</span> <span class="keyword">and</span> c5<span class="operator">=</span><span class="string">&#x27;a5&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> c3,c2;  </span><br><span class="line">   排序字段已经是常量了，这里没有filesort</span><br><span class="line">   </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 之前必排序，与<span class="keyword">order</span> <span class="keyword">by</span> 类似</span><br><span class="line">(<span class="number">8</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c4<span class="operator">=</span><span class="string">&#x27;a4&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> c2,c3;  用c1查询</span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>)explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test03 <span class="keyword">where</span> c1<span class="operator">=</span><span class="string">&#x27;a1&#x27;</span> <span class="keyword">and</span> c4<span class="operator">=</span><span class="string">&#x27;a4&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> c3,c2;  </span><br><span class="line">   <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> temporary; <span class="keyword">Using</span> filesort  </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一般性建议</span></span><br><span class="line">对于单值索引，尽量选择针对当前query过滤性更好的索引</span><br><span class="line">在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</span><br><span class="line">在选择组合索引的时候，尽量选择可以能够包含当前query中的<span class="keyword">where</span>字句中更多字段的索引</span><br><span class="line">尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</span><br></pre></td></tr></table></figure>
<h4 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 保证被驱动表的<span class="keyword">join</span>字段已经被索引（<span class="keyword">join</span>后的表为被驱动表 (需要被查询)）</span><br><span class="line"><span class="number">2.</span> <span class="keyword">left</span> <span class="keyword">join</span> 时，选择小表作为驱动表，大表作为被驱动表。</span><br><span class="line">	 a <span class="keyword">left</span> <span class="keyword">join</span> b 索引加在 b  </span><br><span class="line">     a <span class="keyword">right</span> <span class="keyword">join</span> b 索引加在a</span><br><span class="line"><span class="number">3.</span> <span class="keyword">inner</span> <span class="keyword">join</span> 时，MySQL会自己帮你把小结果集的表选为驱动表。 </span><br><span class="line">	（驱动表无论如何都会被全表扫描，所以扫描次数越少越好）</span><br><span class="line"><span class="number">4.</span> 子查询尽量不要放在被驱动表，有可能使用不到索引。</span><br><span class="line">	若必须用到子查询，可将子查询设置为驱动表，因为驱动表的type 肯定是 <span class="keyword">all</span>，</span><br><span class="line">	而子查询返回的结果表没有索引，必定也是<span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<h4 id="子查询优化-用in-还是-exists"><a href="#子查询优化-用in-还是-exists" class="headerlink" title="子查询优化 (用in 还是 exists)"></a>子查询优化 (用in 还是 exists)</h4><p> <img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/66.png" alt="66"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/67.png" alt="67"></p>
<h4 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h4><p>ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/68.png" alt="68"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/69.png" alt="69"></p>
<p>MySQL支持二种方式的排序，FileSort和Index，Index效率高。它指MySQL扫描索引本身完成排序。FileSort方式效率较低。ORDER BY满足两情况，会使用Index方式排序:</p>
<ol>
<li>ORDER BY 语句使用索引最左前列</li>
<li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li>
</ol>
<ul>
<li><p>在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/70.png" alt="70"></p>
</li>
</ul>
<p>具体下面看几个例子：id 为主键，index(a, b, c)</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/71.png" alt="71"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/72.png" alt="72"></p>
<ul>
<li>filesort有两种算法：双路排序和单路排序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 双路排序</span></span><br><span class="line">MySQL <span class="number">4.1</span>之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。</span><br><span class="line">从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单路排序</span></span><br><span class="line">从磁盘读取查询需要的所有列，按照<span class="keyword">order</span> <span class="keyword">by</span>列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结论及引申出的问题</span></span><br><span class="line">由于单路是后出的，总体而言好过双路</span><br><span class="line">但是用单路有问题，在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I<span class="operator">/</span>O。本来想省一次I<span class="operator">/</span>O操作，反而导致了大量的I<span class="operator">/</span>O操作，反而得不偿失。</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 优化策略</span></span><br><span class="line">增大sort_buffer_size参数的设置  <span class="operator">-</span>用于单路排序的内存大小</span><br><span class="line">增大max_length_for_sort_data参数的设置  <span class="operator">-</span>单次排序字段大小。(单次排序请求)</span><br><span class="line">去掉<span class="keyword">select</span> 后面不需要的字段</span><br></pre></td></tr></table></figure>
<h4 id="group-by关键字优化"><a href="#group-by关键字优化" class="headerlink" title="group by关键字优化"></a>group by关键字优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>实质是先排序后进行分组，遵照索引建的最佳左前缀</span><br><span class="line">当无法使用索引列，增大max_length_for_sort_data参数的设置 <span class="operator">+</span> 增大sort_buffer_size参数的设置</span><br><span class="line"><span class="keyword">where</span> 高于 <span class="keyword">having</span>，能写在<span class="keyword">where</span>限定的条件就不要去<span class="keyword">having</span>限定了。</span><br></pre></td></tr></table></figure>
<h4 id="去重优化"><a href="#去重优化" class="headerlink" title="去重优化"></a>去重优化</h4><p>尽量不要使用 distinct 关键字去重</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t_mall_sku 表</span><br><span class="line">id      shp_id   kcdz                </span><br><span class="line"><span class="comment">------  ------ --------------------</span></span><br><span class="line">   <span class="number">3</span>       <span class="number">1</span>    北京市昌平区  </span><br><span class="line">   <span class="number">4</span>       <span class="number">1</span>    北京市昌平区  </span><br><span class="line">   <span class="number">5</span>       <span class="number">5</span>    北京市昌平区  </span><br><span class="line">   <span class="number">6</span>       <span class="number">3</span>    重庆              </span><br><span class="line">   <span class="number">8</span>       <span class="number">8</span>    天津              </span><br><span class="line">例子：<span class="keyword">select</span> <span class="keyword">distinct</span> kcdz form t_mall_sku <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>)   </span><br><span class="line">使用 <span class="keyword">distinct</span> 关键字去重消耗性能</span><br><span class="line">优化：<span class="keyword">select</span> kcdz form t_mall_sku <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span> )  <span class="keyword">group</span> <span class="keyword">by</span> kcdz 能够利用到索引</span><br></pre></td></tr></table></figure>
<h4 id="分页查询的优化—limit"><a href="#分页查询的优化—limit" class="headerlink" title="分页查询的优化—limit"></a>分页查询的优化—limit</h4><p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/74.png" alt="74"></p>
<p>优化：先利用覆盖索引把要取的数据行的主键取到，然后再用这个主键列与数据表做关联：(查询的数据量小了后)</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/75.png" alt="75"></p>
<h2 id="第三章-查询截取分析"><a href="#第三章-查询截取分析" class="headerlink" title="第三章  查询截取分析"></a>第三章  查询截取分析</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h4 id="查看是否开启及如何开启"><a href="#查看是否开启及如何开启" class="headerlink" title="查看是否开启及如何开启"></a>查看是否开启及如何开启</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认     <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line">开启     <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="什么样的SQL才会记录到慢查询日志"><a href="#什么样的SQL才会记录到慢查询日志" class="headerlink" title="什么样的SQL才会记录到慢查询日志"></a>什么样的SQL才会记录到慢查询日志</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个是由参数long_query_time控制，默认情况下long_query_time的值为<span class="number">10</span>秒。</span><br><span class="line">命令：<span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">可以使用命令修改，也可以在my.cnf参数里面修改。</span><br><span class="line"> </span><br><span class="line">假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在MySQL源码里是判断大于long_query_time，而非大于等于。</span><br></pre></td></tr></table></figure>
<h4 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前多少秒算慢</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置慢的阙值时间</span></span><br><span class="line">使用命令  <span class="string">&#x27;set global long_query_time=1&#x27;</span>  修改为阙值到<span class="number">1</span>秒钟的就是慢<span class="keyword">sql</span></span><br><span class="line">为什么设置后看不出变化？</span><br><span class="line">需要重新连接或新开一个会话才能看到修改值。 <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time%&#x27;</span>;</span><br><span class="line">或者通过<span class="keyword">set</span> session long_query_time<span class="operator">=</span><span class="number">1</span>来改变当前session变量;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 记录慢SQL并后续分析</span></span><br><span class="line"><span class="comment">-- 查询当前系统中有多少条慢查询记录</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="配置版"><a href="#配置版" class="headerlink" title="配置版"></a>配置版</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySQLd下配置：</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">slow_query_log_file<span class="operator">=</span><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>MySQL<span class="operator">/</span>MySQL<span class="operator">-</span>slow.log</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">log_output<span class="operator">=</span>FILE;</span><br></pre></td></tr></table></figure>
<h4 id="日志分析工具MySQLdumpslow"><a href="#日志分析工具MySQLdumpslow" class="headerlink" title="日志分析工具MySQLdumpslow"></a>日志分析工具MySQLdumpslow</h4><p>MySQLdumpslow –help<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/81.png" alt="81"></p>
<p> <img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/82.png" alt="82"></p>
<h4 id="工作常用参考"><a href="#工作常用参考" class="headerlink" title="工作常用参考"></a>工作常用参考</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--得到返回记录集最多的10个SQL</span></span><br><span class="line">MySQLdumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>MySQL<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment">--得到访问次数最多的10个SQL</span></span><br><span class="line">MySQLdumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>MySQL<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment">--得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">MySQLdumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>MySQL<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment">--另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">MySQLdumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>MySQL<span class="operator">/</span>atguigu<span class="operator">-</span>slow.log <span class="operator">|</span> more</span><br></pre></td></tr></table></figure>


<h3 id="大量数据案例"><a href="#大量数据案例" class="headerlink" title="大量数据案例"></a>大量数据案例</h3><p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/76.png" alt="76"></p>
<p>开始优化：<br>思路：尽量让where的过滤条件和排序使用上索引<br>但是一共两个字段(deptno,empno)上有过滤条件，一个字段(ename)有索引 </p>
<ol>
<li><p>我们建一个三个字段的组合索引可否？</p>
<p>create index idx_dno_eno_ena on emp(deptno,empno,ename);<br>但using filesort 依然存在，ename 并没有用到索引。<br>原因是因为empno是一个范围过滤，所以索引后面的字段不会再使用索引了。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/77.png" alt="77"></p>
</li>
<li><p>但是我们可以把索引建成 create index idx_dno_ena on emp(deptno,ename);</p>
</li>
</ol>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/78.png" alt="78"></p>
<ol start="3">
<li> 但是如果我们建立 create index idx_dno_eno on emp(deptno,empno);  而放弃ename使用索引呢？</li>
</ol>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/79.png" alt="79"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/80.png" alt="80"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原因是所有的排序都是在条件过滤之后才执行的，所以如果条件过滤了大部分数据的话，几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序但实际提升性能很有限。 相对的 empno&lt;100100 这个条件如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 结论： 当范围条件和group by 或者 order by  的字段出现二选一时 ，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</span></span><br></pre></td></tr></table></figure>
<h3 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h3><p>MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 看看当前的MySQL版本是否支持</span><br><span class="line">	<span class="keyword">Show</span>  variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;  默认是关闭，使用前需要开启</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span> 开启功能，默认是关闭，使用前需要开启</span><br><span class="line">	<span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line">	<span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span> 运行<span class="keyword">SQL</span> </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 查看结果，<span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 诊断<span class="keyword">SQL</span>，<span class="keyword">show</span> profile cpu, block io <span class="keyword">for</span> query n  (n为上一步前面的问题<span class="keyword">SQL</span>数字号码);</span><br><span class="line"> 	参数备注： </span><br><span class="line"> 	<span class="operator">|</span> <span class="keyword">ALL</span>                    <span class="comment">--显示所有的开销信息  </span></span><br><span class="line"> 	<span class="operator">|</span> BLOCK IO               <span class="comment">--显示块IO相关开销  </span></span><br><span class="line"> 	<span class="operator">|</span> CONTEXT SWITCHES 		<span class="comment">--上下文切换相关开销  </span></span><br><span class="line"> 	<span class="operator">|</span> CPU              		<span class="comment">--显示CPU相关开销信息  </span></span><br><span class="line"> 	<span class="operator">|</span> IPC              		<span class="comment">--显示发送和接收相关开销信息  </span></span><br><span class="line"> 	<span class="operator">|</span> MEMORY           		<span class="comment">--显示内存相关开销信息  </span></span><br><span class="line"> 	<span class="operator">|</span> PAGE FAULTS      		<span class="comment">--显示页面错误相关开销信息  </span></span><br><span class="line"> 	<span class="operator">|</span> SOURCE           		<span class="comment">--显示和Source_function，Source_file，Source_line相关的开销信息  </span></span><br><span class="line"> 	<span class="operator">|</span> SWAPS            		<span class="comment">--显示交换次数相关开销的信息</span></span><br><span class="line"> </span><br><span class="line"><span class="number">6.</span> 日常开发需要注意的结论</span><br><span class="line">	converting HEAP <span class="keyword">to</span> MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</span><br><span class="line">	Creating tmp <span class="keyword">table</span> 创建临时表。拷贝数据到临时表, 用完再删除。</span><br><span class="line">	Copying <span class="keyword">to</span> tmp <span class="keyword">table</span> <span class="keyword">on</span> disk 把内存中临时表复制到磁盘，危险。</span><br><span class="line">	locked</span><br></pre></td></tr></table></figure>
<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><ul>
<li><p>配置启用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在MySQL的my.cnf中，设置如下：</span><br><span class="line"># 开启</span><br><span class="line">general_log<span class="operator">=</span><span class="number">1</span>   </span><br><span class="line"># 记录日志文件的路径</span><br><span class="line">general_log_file<span class="operator">=</span><span class="operator">/</span>path<span class="operator">/</span>logfile</span><br><span class="line"># 输出格式</span><br><span class="line">log_output<span class="operator">=</span>FILE</span><br></pre></td></tr></table></figure></li>
<li><p>编码启用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 全局日志可以存放到日志文件中，也可以存放到MySQL系统表中。存放到日志中性能更好一些，存储到表中</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output<span class="operator">=</span><span class="string">&#x27;TABLE&#x27;</span>;</span><br><span class="line">此后，你所编写的<span class="keyword">sql</span>语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> MySQL.general_log;</span><br></pre></td></tr></table></figure></li>
<li><p>尽量不要在生产环境开启这个功能。</p>
</li>
</ul>
<h2 id="第四章-主从复制"><a href="#第四章-主从复制" class="headerlink" title="第四章  主从复制"></a>第四章  主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><p>slave 会从 master 读取 binlog 来进行数据同步</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/83.png" alt="83"></p>
<blockquote>
<p>MySQL复制过程分成三步：<br>1 master将改变记录到二进制日志binary log。这些记录过程叫做二进制日志事件，binary log events；<br>2 slave 将master的binary log events拷贝到它的中继日志（relay log）；<br>3 slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的。</p>
</blockquote>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个slave只有一个master</span><br><span class="line">每个slave只能有一个唯一的服务器ID</span><br><span class="line">每个master可以有多个salve</span><br></pre></td></tr></table></figure>

<h3 id="复制的最大问题-延时"><a href="#复制的最大问题-延时" class="headerlink" title="复制的最大问题 -延时"></a>复制的最大问题 -延时</h3><h3 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h3><ol>
<li><p>MySQL版本一致且后台以服务运行</p>
</li>
<li><p>主从都配置在[MySQLd]结点下，都是小写</p>
</li>
<li><p>主机修改my.ini配置文件</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/84.png" alt="84"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/85.png" alt="85"></p>
</li>
</ol>
<ol start="4">
<li><p>从机修改my.cnf配置文件</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/86.png" alt="86"></p>
</li>
<li><p>因修改过配置文件，请主机+从机都重启后台MySQL服务</p>
</li>
<li><p>主机从机都关闭防火墙</p>
</li>
<li><p>在Windows主机上建立帐户并授权slave</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;121.121.121.121&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="number">2.</span> flush privileges;</span><br><span class="line"><span class="number">3.</span> 查询master的状态</span><br><span class="line">	<span class="keyword">show</span> master status;</span><br><span class="line">	记录下File和Position的值</span><br><span class="line"><span class="number">4.</span> 执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化</span><br></pre></td></tr></table></figure></li>
<li><p>在Linux从机上配置需要复制的主机</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;主机IP&#x27;</span>,</span><br><span class="line">	MASTER_USER<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">	MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">	MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;File名字&#x27;</span>,</span><br><span class="line">	MASTER_LOG_POS<span class="operator">=</span>Position数字;</span><br><span class="line"><span class="number">2.</span> 启动从服务器复制功能  <span class="keyword">start</span> slave;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">show</span> slave status</span><br><span class="line">	下面两个参数都是Yes，则说明主从配置成功！</span><br><span class="line">	Slave_IO_Running: Yes</span><br><span class="line">	Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure></li>
<li><p>主机新建库、新建表、insert记录，从机复制</p>
</li>
<li><p>如何停止从服务复制功能    stop slave;</p>
</li>
</ol>
<h2 id="第五章-MySQL锁机制"><a href="#第五章-MySQL锁机制" class="headerlink" title="第五章  MySQL锁机制"></a>第五章  MySQL锁机制</h2><pre><code>锁是计算机协调多个进程或线程并发访问某一资源的机制。

从对数据操作的类型（读\写）来看：
1.  读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。
2.  写锁(排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。

从对数据操作的粒度分来看：
1. 表锁
2. 行锁</code></pre>
<h3 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1. 偏向MyISAM存储引擎，开销小，加锁快；</span><br><span class="line">2. 无死锁；</span><br><span class="line">3. 锁定粒度大，发生锁冲突的概率最高, 并发度最低。</span><br></pre></td></tr></table></figure>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mylock(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> <span class="keyword">key</span> auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)engine myisam;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">【手动增加表锁】</span><br><span class="line"> lock <span class="keyword">table</span> 表名字<span class="number">1</span> read(write)，表名字<span class="number">2</span> read(write)，其它;</span><br><span class="line">【查看表上加过的锁】</span><br><span class="line">  <span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line">【释放表锁】</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<ul>
<li>加读锁 ：我们为mylock表加read锁(读阻塞写例子)</li>
</ul>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/87.png" alt="87"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/88.png" alt="88"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/89.png" alt="89"></p>
<ul>
<li>加写锁</li>
</ul>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/90.png" alt="90"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/91.png" alt="91"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/92.png" alt="92"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyISAM在执行查询语句<span class="keyword">SELECT</span>前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。 </span><br><span class="line"></span><br><span class="line">MySQL的表级锁有两种模式：</span><br><span class="line"> 表共享读锁（<span class="keyword">Table</span> Read Lock）</span><br><span class="line"> 表独占写锁（<span class="keyword">Table</span> Write Lock）</span><br><span class="line"> </span><br><span class="line">锁类型  	他人可读	他人可写</span><br><span class="line">读锁	       是	      否</span><br><span class="line">写锁	       否	      否</span><br><span class="line"> </span><br><span class="line">结论：</span><br><span class="line">结合上表，所以对MyISAM表进行操作，会有以下情况： </span><br><span class="line">  <span class="number">1</span>、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读	锁释放后，才会执行其它进程的写操作。 </span><br><span class="line">  <span class="number">2</span>、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进	程的读写操作。</span><br><span class="line"> 简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。</span><br></pre></td></tr></table></figure>
<h3 id="行锁-偏写"><a href="#行锁-偏写" class="headerlink" title="行锁(偏写)"></a>行锁(偏写)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点:</span><br><span class="line">1. 偏向InnoDB存储引擎，开销大，加锁慢；</span><br><span class="line">2. 会出现死锁；</span><br><span class="line">3. 锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</span><br><span class="line">4. InnoDB 与 MyISAM的最大不同有两点：一是支持事务，二是采用了行级锁</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发事务处理带来的问题:</span><br><span class="line">1. 更新丢失    一个事务的更新覆盖了由其他事务所做的更新。</span><br><span class="line">2. 脏读</span><br><span class="line">3. 不可重复读 </span><br><span class="line">4. 幻读    事务A 读取到了事务B提交的新增数据，不符合隔离性。 </span><br><span class="line"></span><br><span class="line">Repeatable Read从理论的角度是会出现幻读的，所以MySQL内部通过多版本控制机制【实际上就是对读取到的数据加锁】解决这个问题。最后，用户才可以放心大胆使用Repeatable Read这个事务隔离级别。</span><br></pre></td></tr></table></figure>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_innodb_lock (a <span class="type">int</span>(<span class="number">11</span>),b <span class="type">varchar</span>(<span class="number">16</span>))engine<span class="operator">=</span>innodb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;b2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;4000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;6000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;7000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;8000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">&#x27;9000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;b1&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> index test_innodb_a_ind <span class="keyword">on</span> test_innodb_lock(a);</span><br><span class="line"><span class="keyword">create</span> index test_innodb_lock_b_ind <span class="keyword">on</span> test_innodb_lock(b);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>行锁定基本演示</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/93.png" alt="93"></p>
</li>
<li><p>无索引行锁升级为表锁</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/94.png" alt="94"></p>
</li>
<li><p>Select也可以加锁</p>
<ol>
<li><p>读锁</p>
<blockquote>
<p>共享锁(Share Lock)<br>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p>
<p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p>
<p>用法  SELECT … LOCK IN SHARE MODE;</p>
<p>在查询语句后面增加 LOCK IN SHARE MODE ，MySQL会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p>
</blockquote>
</li>
<li><p>写锁</p>
<blockquote>
<p>排他锁（eXclusive Lock）<br>共享锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获得排他锁的事务既能读数据，又能修改数据。</p>
<p>用法  SELECT … FOR UPDATE;</p>
<p>在查询语句后面增加 FOR UPDATE ，MySQL会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>间隙锁危害</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/95.png" alt="95"></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【什么是间隙锁】</span><br><span class="line">当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做间隙GAP，InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁GAP Lock 。</span><br><span class="line"></span><br><span class="line">【危害】</span><br><span class="line">因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</span><br><span class="line">间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如何锁定一行    </p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/96.png" alt="96"></p>
</li>
</ul>
<h4 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。</span><br><span class="line"></span><br><span class="line">当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。但是Innodb的行级锁定同样也有其脆弱的一面，当使用不当的时，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</span><br></pre></td></tr></table></figure>
<h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如何分析行锁定</span></span><br><span class="line">通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</span><br><span class="line">MySQL<span class="operator">&gt;</span><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">对各个状态量的说明如下：</span><br><span class="line">Innodb_row_lock_current_waits： 当前正在等待锁定的数量；</span><br><span class="line">Innodb_row_lock_time：          从系统启动到现在锁定总时间长度；</span><br><span class="line">Innodb_row_lock_time_avg：      每次等待所花平均时间；</span><br><span class="line">Innodb_row_lock_time_max：      从系统启动到现在等待最常的一次所花的时间；</span><br><span class="line">Innodb_row_lock_waits：         系统启动后到现在总共等待的次数；</span><br><span class="line"></span><br><span class="line">对于这<span class="number">5</span>个状态变量，比较重要的主要是</span><br><span class="line">  Innodb_row_lock_time_avg  （等待平均时长），</span><br><span class="line">  Innodb_row_lock_waits     （等待总次数）</span><br><span class="line">  Innodb_row_lock_time      （等待总时长）</span><br><span class="line">尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计。</span><br><span class="line"> </span><br><span class="line">最后可以通过 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX\G; 来查询正在被锁阻塞的<span class="keyword">sql</span>语句。</span><br></pre></td></tr></table></figure>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</span><br><span class="line">尽可能较少检索条件，避免间隙锁</span><br><span class="line">尽量控制事务大小，减少锁定资源量和时间长度</span><br><span class="line">锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁。</span><br><span class="line">涉及相同表的事务，对于调用表的顺序尽量保持一致。</span><br><span class="line">在业务环境允许的情况下,尽可能低级别事务隔离</span><br></pre></td></tr></table></figure>


<h2 id="第六章-MySQL事务的实现原理"><a href="#第六章-MySQL事务的实现原理" class="headerlink" title="第六章  MySQL事务的实现原理"></a>第六章  MySQL事务的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务想要做到什么效果？按我理解，无非是要做到可靠性以及并发处理</span><br><span class="line">- 可靠性：数据库要保证当 insert 或 update 操作时抛异常或者数据库 crash 的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了 undo log 和 redo log。</span><br><span class="line">- 并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面首先讲实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC，然后再讲事务的实现原理，最后在做一个总结。</span><br><span class="line">- redo log 与 undo log介绍</span><br><span class="line">- MySQL锁技术以及MVCC基础</span><br><span class="line">- 事务的实现原理</span><br><span class="line">- 总结</span><br></pre></td></tr></table></figure>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redo log叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。</span><br><span class="line"></span><br><span class="line">当事务提交之后会把所有修改信息都会存到该日志中。</span><br></pre></td></tr></table></figure>
<p>假设有个表叫做tb1(id,username) ，现在要插入数据（3，ceshi）</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/97.png" alt="97"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> balance <span class="keyword">from</span> bank <span class="keyword">where</span> name<span class="operator">=</span>&quot;zhangsan&quot;;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 生成 重做日志 balance<span class="operator">=</span><span class="number">600</span></span><br><span class="line"><span class="keyword">update</span> bank <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">400</span>; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 生成 重做日志 amount<span class="operator">=</span><span class="number">400</span></span><br><span class="line"><span class="keyword">update</span> finance <span class="keyword">set</span> amount <span class="operator">=</span> amount <span class="operator">+</span> <span class="number">400</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/98.png" alt="98"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redo log 有什么作用？</span><br><span class="line">MySQL 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。</span><br><span class="line">那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</span><br><span class="line">所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</span><br><span class="line"></span><br><span class="line">总结：redo log是用来恢复数据的,  用于保障已提交事务的持久化特性</span><br></pre></td></tr></table></figure>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undo log 叫做回滚日志，用于记录数据被修改前的信息。正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/99.png" alt="99"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。</span><br><span class="line"></span><br><span class="line">undo log 有什么作用？</span><br><span class="line">undo log 记录事务修改之前版本的数据信息，假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</span><br><span class="line"></span><br><span class="line">总结：undo log是用来回滚数据的，用于保障未提交事务的原子性</span><br></pre></td></tr></table></figure>

<h3 id="MySQL锁技术"><a href="#MySQL锁技术" class="headerlink" title="MySQL锁技术"></a>MySQL锁技术</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">共享锁(shared lock), 又叫做&quot;读锁&quot;</span><br><span class="line">读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</span><br><span class="line"></span><br><span class="line">排他锁(exclusive lock),又叫做&quot;写锁&quot;</span><br><span class="line">写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/100.png" alt="100"></p>
<p>总结：通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行。 事务的隔离性就是根据读写锁来实现的！！！这个后面再说。</p>
<h3 id="MVCC基础"><a href="#MVCC基础" class="headerlink" title="MVCC基础"></a>MVCC基础</h3><h4 id="1-前提概要"><a href="#1-前提概要" class="headerlink" title="1. 前提概要"></a>1. 前提概要</h4><h5 id="什么是MVCC-？"><a href="#什么是MVCC-？" class="headerlink" title="什么是MVCC ？"></a>什么是MVCC ？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。</span><br><span class="line">MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</span><br></pre></td></tr></table></figure>
<h5 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</span><br><span class="line"></span><br><span class="line">- 当前读</span><br><span class="line">像select lock in share mode (共享锁),   select for update ;   update,   insert ,  delete (排他锁) 这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</span><br><span class="line"></span><br><span class="line">- 快照读</span><br><span class="line">像不加锁的  select  操作就是快照读，即不加锁的非阻塞读；</span><br><span class="line">快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；</span><br><span class="line">之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC,  可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；</span><br><span class="line">快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</span><br><span class="line"></span><br><span class="line">说白了 MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是快照读,  而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。</span><br></pre></td></tr></table></figure>
<h5 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</span><br><span class="line"></span><br><span class="line">而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</span><br><span class="line"></span><br><span class="line">要说的再细致一些，快照读本身也是一个抽象概念。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</span><br></pre></td></tr></table></figure>

<h5 id="MVCC能解决什么问题，好处是？"><a href="#MVCC能解决什么问题，好处是？" class="headerlink" title="MVCC能解决什么问题，好处是？"></a>MVCC能解决什么问题，好处是？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据库并发场景有三种，分别为：</span><br><span class="line">- 读-读：不存在任何问题</span><br><span class="line">- 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</span><br><span class="line">- 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MVCC带来的好处是？</span><br><span class="line">MVCC是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。所以MVCC可以为数据库解决以下问题:</span><br><span class="line"></span><br><span class="line">- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写性能</span><br><span class="line">- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</span><br><span class="line"></span><br><span class="line">- MVCC + 悲观锁</span><br><span class="line">  MVCC解决读写冲突，悲观锁解决写写冲突</span><br><span class="line">  </span><br><span class="line">- MVCC + 乐观锁</span><br><span class="line">  MVCC解决读写冲突，乐观锁解决写写冲突</span><br><span class="line">  这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</span><br></pre></td></tr></table></figure>
<h4 id="2-MVCC的实现原理"><a href="#2-MVCC的实现原理" class="headerlink" title="2. MVCC的实现原理"></a>2. MVCC的实现原理</h4><p>MVCC的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现。</p>
<p><strong>隐式字段</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">隐式字段：每行记录除了自定义的字段，还有数据库隐式定义的DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID等字段</span><br><span class="line"><span class="comment">-- DB_TRX_ID</span></span><br><span class="line">  <span class="number">6</span>byte，最近修改(修改<span class="operator">/</span>插入)事务ID：记录创建这条记录<span class="operator">/</span>最后一次修改该记录的事务ID</span><br><span class="line"><span class="comment">-- DB_ROLL_PTR</span></span><br><span class="line">  <span class="number">7</span>byte，回滚指针，指向这条记录的上一个版本（存储于<span class="keyword">rollback</span> segment里）</span><br><span class="line"><span class="comment">-- DB_ROW_ID</span></span><br><span class="line">  <span class="number">6</span>byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</span><br><span class="line"><span class="comment">-- 实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了</span></span><br><span class="line"></span><br><span class="line">如图，DB_ROW_ID  是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID  是当前操作该记录的事务ID, 而  DB_ROLL_PTR  是一个回滚指针，用于配合 undo 日志，指向上一个旧版本。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/108.png" alt="108"></p>
<p><strong>undo日志</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">undo log主要分为两种：</span><br><span class="line">1. insert undo log</span><br><span class="line">代表事务在insert新记录时产生的undo log,  只在事务回滚时需要，并且在事务提交后可以被立即丢弃</span><br><span class="line"></span><br><span class="line">2. update undo log</span><br><span class="line">事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</span><br><span class="line"></span><br><span class="line">3. purge</span><br><span class="line">为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</span><br><span class="line"></span><br><span class="line">为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）; 如果某个记录的deleted_bit为true，并且 DB_TRX_ID 相对于purge线程的read view可见，那么这条记录可以被安全清除。</span><br></pre></td></tr></table></figure>
<p>对MVCC有帮助的实质是 update undo log ，undo log 实际上就是存在 rollback segment 中旧记录链，它的执行流程如下：</p>
<ol>
<li><p>比如一个有个事务插入person表插入了一条新记录，记录如下，name为Jerry,  age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/109.png" alt="109"></p>
</li>
<li><p>现在来了一个事务1对该记录的 name 做出了修改，改为 Tom</p>
<ul>
<li>在事务1修改该行数据时，数据库会先对该行加排他锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧记录，即在undo log中有当前行的拷贝副本</li>
<li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li>
<li>事务提交后，释放锁</li>
</ul>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/110.png" alt="110"></p>
</li>
<li><p>又来了个事务2修改person表的同一个记录，将age修改为30岁</p>
<ul>
<li>在事务2修改该行数据时，数据库也先为该行加锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li>
<li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li>
<li>事务提交，释放锁</li>
</ul>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/111.png" alt="111"></p>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的 undo log 成为一条记录版本的链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该 undo log 的节点可能是会被 purge 线程清除掉，像图中的第一条 insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
</li>
</ol>
<p><strong>Read View(读视图)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Read View 就是事务进行快照读操作的时候生产的读视图 (Read View)，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID (当每个事务开启时，都会被分配一个ID,  这个ID是递增的，所以越新的事务，ID值越大)。</span><br><span class="line"></span><br><span class="line">Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它作为条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</span><br><span class="line"></span><br><span class="line">Read View遵循一个可见性算法，主要是将 要被修改数据的最新记录中的 DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID, 那么这个DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版本。</span><br></pre></td></tr></table></figure>
<p><strong>那么这个判断条件是什么呢？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在展示之前，先简化一下Read View，可以把 Read View 简单的理解成有三个全局属性</span><br><span class="line">1. tx_list   一个数值列表，用来维护 Read View 生成时刻系统正活跃的事务 ID</span><br><span class="line">2. up_limit_id  记录 tx_list 列表中事务 ID 最小的 ID</span><br><span class="line">3. low_limit_id  ReadView 生成时刻系统尚未分配的下一个事务ID，即目前已出现过的事务ID的最大值+1</span><br><span class="line"></span><br><span class="line">1. 首先比较 DB_TRX_ID  &lt;  up_limit_id,  如果小于，则当前事务能看到 DB_TRX_ID 所在的记录，如果大于等于    进入下一个判断</span><br><span class="line">2. 接下来判断 DB_TRX_ID  大于等于  low_limit_id ,  如果大于等于则代表 DB_TRX_ID 所在的记录在 Read      View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</span><br><span class="line">3. 判断 DB_TRX_ID 是否在活跃事务之中，tx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时      刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明你这个事    务在Read View生成之前就已经Commit了，修改的结果当前事务是能看见的。</span><br></pre></td></tr></table></figure>
<h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><p>在了解了隐式字段，undo log， 以及Read View之后，就可以来看看MVCC实现的整体流程是怎么样了</p>
<ul>
<li><p>当事务2 对某行数据执行了快照读，数据库为该行数据生成一个 Read View 读视图，假设当前事务 ID 为2，此时还有事务1 和事务3 在活跃中，事务4 在事务2 快照读前一刻提交更新了，所以 Read View 记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为tx_list。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/112.png" alt="112"></p>
</li>
<li><p>Read View不仅仅会通过一个列表tx_list来维护事务 2 执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录tx_list列表中事务ID最小的ID），low_limit_id(记录tx_list列表中事务ID最大的ID，也有人说目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里 up_limit_id 就是 1，low_limit_id 就是 4 + 1 = 5，tx_list 集合的值是 1,3，Read View 如下图。<br><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/113.png" alt="113"></p>
</li>
<li><p>我们的例子中，只有事务4 修改过该行记录，并在事务2 执行快照读前，就提交了事务，所以当前该行的 undo log 如下图所示；我们的事务2 在快照读该行记录的时候，就会拿该行记录的 DB_TRX_ID 去跟up_limit_id, low_limit_id 和活跃事务ID 列表 (tx_list) 进行比较，判断当前事务2 能看到该记录的版本是哪个。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/114.png" alt="114"></p>
</li>
<li><p>所以先拿该记录 DB_TRX_ID 字段记录的事务ID 4 去跟 Read View 的的 up_limit_id 比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于  low_limit_id(5)， 也不符合条件，最后判断4是否处于  tx_list  中的活跃事务, 最后发现事务ID 为4 的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4 修改后提交的最新结果对事务2 快照读时是可见的，所以事务2 能读到的最新数据记录是 事务4 提交的版本，而事务4 提交的版本也是全局角度上最新的版本。</p>
</li>
<li><p>也正是 Read View 生成时机的不同，从而造成 RC,  RR 级别下快照读的结果的不同。</p>
</li>
</ul>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/115.png" alt="115"></p>
<h5 id="放大图后看过程"><a href="#放大图后看过程" class="headerlink" title="放大图后看过程"></a>放大图后看过程</h5><p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc1.png" alt="mvcc1"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc2.png" alt="mvcc2"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc3.png" alt="mvcc3"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/mvcc4.png" alt="mvcc4"></p>
<h4 id="3-MVCC相关问题"><a href="#3-MVCC相关问题" class="headerlink" title="3. MVCC相关问题"></a>3. MVCC相关问题</h4><h5 id="RR-是如何在-RC-级的基础上解决不可重复读的？"><a href="#RR-是如何在-RC-级的基础上解决不可重复读的？" class="headerlink" title="RR 是如何在 RC 级的基础上解决不可重复读的？"></a>RR 是如何在 RC 级的基础上解决不可重复读的？</h5><p>当前读和快照读在RR级别下的区别：</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/116.png" alt="116"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/117.png" alt="117"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在第二张表中，事务B 在事务A 提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</span><br><span class="line">- 这里与第一张表的唯一区别仅仅是表1 的事务B 在事务A 修改金额前快照读过一次金额数据，而表2 的事务B在事务A修改金额前没有进行过快照读。</span><br><span class="line"></span><br><span class="line">- 所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力。</span><br><span class="line"></span><br><span class="line">- 这里测试的是更新，同时删除和更新也是一样的，如果事务B 的快照读是在事务A 操作之后进行的，事务B的快照读也是能读取到最新的数据的。</span><br></pre></td></tr></table></figure>

<h5 id="RC-RR级别下的-InnoDB-快照读有什么不同？"><a href="#RC-RR级别下的-InnoDB-快照读有什么不同？" class="headerlink" title="RC,  RR级别下的 InnoDB 快照读有什么不同？"></a>RC,  RR级别下的 InnoDB 快照读有什么不同？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">正是Read View生成时机的不同，从而造成RC, RR级别下快照读的结果的不同。</span><br><span class="line"></span><br><span class="line">- 在 RR 级别下的某个事务对某条记录的第一次快照读会创建一个快照及Read View,  将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</span><br><span class="line"></span><br><span class="line">- 即RR级别下，快照读生成 Read View 时，Read View 会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于 Read View 创建的事务所做的修改均是可见。</span><br><span class="line"></span><br><span class="line">- 而在RC级别下的事务中，每次快照读都会新生成一个快照和 Read View , 这就是我们在 RC 级别下的事务中可以看到别的事务提交的更新的原因。</span><br><span class="line"></span><br><span class="line">总之在 RC 隔离级别下，是每个快照读都会生成并获取最新的 Read View；而在 RR 隔离级别下，则是同一个事务中的第一个快照读才会创建 Read View , 之后的快照读获取的都是同一个 Read View。</span><br></pre></td></tr></table></figure>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</span><br><span class="line">- 事务的原子性是通过 undo log 来实现的</span><br><span class="line">- 事务的持久性性是通过 redo log 来实现的</span><br><span class="line">- 事务的隔离性是通过 (读写锁+MVCC)来实现的</span><br><span class="line">- 而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！</span><br><span class="line">原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！</span><br><span class="line">总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</span><br></pre></td></tr></table></figure>
<h4 id="原子性的实现"><a href="#原子性的实现" class="headerlink" title="原子性的实现"></a>原子性的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么是原子性：一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。</span><br><span class="line"></span><br><span class="line">那么数据库是怎么实现的呢？就是通过回滚操作。所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样，所以这时候就需要用到undo log来进行回滚，接下来看一下undo log在实现事务原子性时怎么发挥作用的。</span><br></pre></td></tr></table></figure>
<h5 id="1-undo-log-的生成"><a href="#1-undo-log-的生成" class="headerlink" title="1. undo log 的生成"></a>1. undo log 的生成</h5><p>假设有两个表  bank 和  finance，表中原始数据如图所示，当进行插入，删除以及更新操作时生成的 undo log 如下面图所示：<img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/99.png" alt="99"></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/101.png" alt="101"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从上图可以了解到数据的变更都伴随着回滚日志的产生：</span><br><span class="line">(1) 产生了被修改前数据(zhangsan,1000) 的回滚日志</span><br><span class="line">(2) 产生了被修改前数据(zhangsan,0) 的回滚日志</span><br><span class="line"></span><br><span class="line">根据上面流程可以得出如下结论：</span><br><span class="line">1. 每条数据变更(insert&#x2F;update&#x2F;delete)都伴随一条undo log的生成，并且回滚日志必须先于数据持久化到磁盘上</span><br><span class="line">2. 所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考：为什么先写日志后写数据库？—稍后做解释</p>
</blockquote>
<h5 id="2-根据undo-log-进行回滚"><a href="#2-根据undo-log-进行回滚" class="headerlink" title="2. 根据undo log 进行回滚"></a>2. 根据undo log 进行回滚</h5><p>为了做到同时成功或者失败，当系统发生错误或者执行rollback操作时需要根据undo log 进行回滚</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/102.png" alt="102"></p>
<p>回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p>
<ul>
<li>如果在回滚日志里有新增数据记录，则生成删除该条的语句</li>
<li>如果在回滚日志里有删除数据记录，则生成生成该条的语句</li>
<li>如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</li>
</ul>
<h4 id="持久性的实现"><a href="#持久性的实现" class="headerlink" title="持久性的实现"></a>持久性的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">事务一旦提交，其所做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</span><br><span class="line"></span><br><span class="line">MySQL的表数据存放在磁盘上，因此想要存取的时候都要经历磁盘IO，即使是使用SSD磁盘IO也是非常消耗性能的。</span><br><span class="line">为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：</span><br><span class="line">- 读数据：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取再放入缓冲池；</span><br><span class="line">- 写数据：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</span><br><span class="line">这种缓冲池的措施在性能方面带来了质的飞跃，但也带来了新的问题，当MySQL系统宕机，断电时可能会丢数据！</span><br><span class="line">因为数据已经提交，但此时是在缓冲池里，还没来得及在磁盘持久化，所以我们急需一种机制，需要存一下已提交事务的数据，为恢复数据使用。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">于是 redo log就派上用场了。</span><br><span class="line">事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/98.png" alt="98"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">既然redo log也需要存储，也涉及磁盘IO为啥还用它？</span><br><span class="line">- redo log 的存储是顺序存储，而缓存同步是随机操作。</span><br><span class="line">- 缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</span><br></pre></td></tr></table></figure>

<h4 id="隔离性实现"><a href="#隔离性实现" class="headerlink" title="隔离性实现"></a>隔离性实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</span><br><span class="line"></span><br><span class="line">MySQL 隔离级别有以下四种（级别由低到高）：</span><br><span class="line">- READ UNCOMMITED </span><br><span class="line">- READ COMMITED </span><br><span class="line">- REPEATABLE READ </span><br><span class="line">- SERIALIZABLE</span><br><span class="line"></span><br><span class="line">只要彻底理解了隔离级别以及实现原理就相当于理解了ACID里的隔离性。</span><br><span class="line">前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离性跟其他两个有所区别。</span><br><span class="line">原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</span><br><span class="line">那么隔离性是要做到什么呢？隔离性是要管理多个并发读写请求的访问顺序。这种顺序包括串行或并行。说明一点，写请求不仅仅是指insert操作，又包括update操作。</span><br><span class="line"></span><br><span class="line">总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。</span><br><span class="line">- 可靠性性高的，并发性能低(比如 Serializable)</span><br><span class="line">- 可靠性低的，并发性能高(比如 Read Uncommited)</span><br></pre></td></tr></table></figure>

<h5 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在READ UNCOMMITTED隔离级别下，事务可以读取未提交的数据，造成脏读。</span><br><span class="line">- 优点：读写并行，性能高</span><br><span class="line">- 缺点：造成脏读</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/103.png" alt="103"></p>
<h5 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个事务在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。</span><br><span class="line">InnoDB中的 READ COMMITTED，使用排它锁，读取数据不加锁而是使用MVCC机制。该级别会产生不可重读以及幻读。</span><br></pre></td></tr></table></figure>
<p><strong>什么是不可重读？</strong></p>
<p>在一个事务内多次读取的结果不一样。</p>
<p><strong>为什么会产生不可重复读？</strong></p>
<p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新生成一个版本号，所以每次select读的不是一个副本而是不同的副本。在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/104.png" alt="104"></p>
<h5 id="REPEATABLE-READ-默认"><a href="#REPEATABLE-READ-默认" class="headerlink" title="REPEATABLE READ(默认)"></a>REPEATABLE READ(默认)</h5><p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免脏读，不可重复读。MySQL有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p>
<p><strong>采用读写锁实现：</strong></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/105.png" alt="105"></p>
<p>为什么能重复读？只要没释放读锁，再次读的时候还是可以读到第一次读的数据。</p>
<ul>
<li>优点：实现起来简单</li>
<li>缺点：无法做到读写并行</li>
</ul>
<p><strong>采用MVCC实现：</strong></p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/106.png" alt="106"></p>
<p>为什么能重复读？因为多次读取只生成一个版本，读到的自然是相同数据。</p>
<ul>
<li>优点：读写并行</li>
<li>缺点：实现的复杂度高</li>
</ul>
<p>但是在该隔离级别下仍会存在幻读的问题。</p>
<h5 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h5><p>该隔离级别理解起来最简单，实现也最简单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p>
<p><img src="/2021/01/25/MySQL%E9%AB%98%E7%BA%A7/107.png" alt="107"></p>
<h4 id="一致性的实现"><a href="#一致性的实现" class="headerlink" title="一致性的实现"></a>一致性的实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据库总是从一个一致性的状态转移到另一个一致性的状态.</span></span><br><span class="line"><span class="comment">-- 下面举个例子:zhangsan 从银行卡转400到理财账户</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> balance <span class="keyword">from</span> bank <span class="keyword">where</span> name<span class="operator">=</span>&quot;zhangsan&quot;;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 生成 重做日志 balance<span class="operator">=</span><span class="number">600</span></span><br><span class="line"><span class="keyword">update</span> bank <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">400</span>; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 生成 重做日志 amount<span class="operator">=</span><span class="number">400</span></span><br><span class="line"><span class="keyword">update</span> finance <span class="keyword">set</span> amount <span class="operator">=</span> amount <span class="operator">+</span> <span class="number">400</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 假如执行完 update bank set balance &#x3D; balance - 400; 发生异常了，银行卡的钱也不能平白无辜的减少，而是回滚到最初状态。</span><br><span class="line">2. 事务提交之后，缓冲池还没同步到磁盘的时候宕机了，这也是不能接受的，应该在重启的时候恢复并持久化。</span><br><span class="line">3. 假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以隔离性也是对一致性的一种破坏。</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag">MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/24/MySQL%E6%95%B4%E7%90%86/" rel="prev" title="MySQL整理">
      <i class="fa fa-chevron-left"></i> MySQL整理
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E9%AB%98%E7%BA%A7"><span class="nav-number">1.</span> <span class="nav-text">MySQL高级</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 MySQL架构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">MySQL中的一些文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.2.</span> <span class="nav-text">MySQL逻辑架构介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.3.</span> <span class="nav-text">MySQL存储引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">第二章  索引优化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Join%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.2.1.</span> <span class="nav-text">常见的Join查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">SQL执行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JOIN%E5%9B%BE"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">JOIN图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E7%A7%8DJOIN"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">7种JOIN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">索引简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90Explain"><span class="nav-number">1.2.3.</span> <span class="nav-text">性能分析Explain</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E5%AD%97%E6%AE%B5%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">各字段的解释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.4.</span> <span class="nav-text">查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">使用索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">关联查询优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E7%94%A8in-%E8%BF%98%E6%98%AF-exists"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">子查询优化 (用in 还是 exists)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#order-by%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">order by关键字优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#group-by%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">group by关键字优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%BB%E9%87%8D%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">去重优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BC%98%E5%8C%96%E2%80%94limit"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">分页查询的优化—limit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">第三章  查询截取分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">慢查询日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">查看是否开启及如何开启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84SQL%E6%89%8D%E4%BC%9A%E8%AE%B0%E5%BD%95%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">什么样的SQL才会记录到慢查询日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Case"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">Case</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%89%88"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">配置版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7MySQLdumpslow"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">日志分析工具MySQLdumpslow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">工作常用参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">大量数据案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Show-Profile"><span class="nav-number">1.3.3.</span> <span class="nav-text">Show Profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">1.3.4.</span> <span class="nav-text">全局查询日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">第四章  主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">复制的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.2.</span> <span class="nav-text">复制的基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98-%E5%BB%B6%E6%97%B6"><span class="nav-number">1.4.3.</span> <span class="nav-text">复制的最大问题 -延时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="nav-number">1.4.4.</span> <span class="nav-text">一主一从常见配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-MySQL%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">第五章  MySQL锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E9%94%81-%E5%81%8F%E8%AF%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">表锁(偏读)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E9%94%81-%E5%81%8F%E5%86%99"><span class="nav-number">1.5.2.</span> <span class="nav-text">行锁(偏写)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-1"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">案例结论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">行锁分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">优化建议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-MySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">第六章  MySQL事务的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log"><span class="nav-number">1.6.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log"><span class="nav-number">1.6.2.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E9%94%81%E6%8A%80%E6%9C%AF"><span class="nav-number">1.6.3.</span> <span class="nav-text">MySQL锁技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">读写锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC%E5%9F%BA%E7%A1%80"><span class="nav-number">1.6.4.</span> <span class="nav-text">MVCC基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%89%8D%E6%8F%90%E6%A6%82%E8%A6%81"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">1. 前提概要</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC-%EF%BC%9F"><span class="nav-number">1.6.4.1.1.</span> <span class="nav-text">什么是MVCC ？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F"><span class="nav-number">1.6.4.1.2.</span> <span class="nav-text">什么是当前读和快照读？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8CMVCC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.6.4.1.3.</span> <span class="nav-text">当前读，快照读和MVCC的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%9F"><span class="nav-number">1.6.4.1.4.</span> <span class="nav-text">MVCC能解决什么问题，好处是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.4.1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">2. MVCC的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.4.2.1.</span> <span class="nav-text">整体流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%BE%E5%A4%A7%E5%9B%BE%E5%90%8E%E7%9C%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">1.6.4.2.2.</span> <span class="nav-text">放大图后看过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">3. MVCC相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RR-%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8-RC-%E7%BA%A7%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%EF%BC%9F"><span class="nav-number">1.6.4.3.1.</span> <span class="nav-text">RR 是如何在 RC 级的基础上解决不可重复读的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RC-RR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84-InnoDB-%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.6.4.3.2.</span> <span class="nav-text">RC,  RR级别下的 InnoDB 快照读有什么不同？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.</span> <span class="nav-text">事务的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">原子性的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-undo-log-%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">1.6.5.1.1.</span> <span class="nav-text">1. undo log 的生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B9%E6%8D%AEundo-log-%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%BB%9A"><span class="nav-number">1.6.5.1.2.</span> <span class="nav-text">2. 根据undo log 进行回滚</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">持久性的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">隔离性实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#READ-UNCOMMITTED"><span class="nav-number">1.6.5.3.1.</span> <span class="nav-text">READ UNCOMMITTED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#READ-COMMITTED"><span class="nav-number">1.6.5.3.2.</span> <span class="nav-text">READ COMMITTED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#REPEATABLE-READ-%E9%BB%98%E8%AE%A4"><span class="nav-number">1.6.5.3.3.</span> <span class="nav-text">REPEATABLE READ(默认)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SERIALIZABLE"><span class="nav-number">1.6.5.3.4.</span> <span class="nav-text">SERIALIZABLE</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.5.4.</span> <span class="nav-text">一致性的实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xudukang"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">xudukang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xdk-nj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xdk-nj" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xudukang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">263k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
